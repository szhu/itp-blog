int Pins[] = {5, 6, 10, 11};
int SwitchPin = 1;

// Strengths
int _ = 0;   // None
int H = 160; // Half
int F = 255; // Full

// Delays
int S = 30;   // Short
int M = 70;   // Medium
int L = 2000; // Long

void setup() {
  Serial.begin(9600);

  for (int i = 0; i < sizeof(Pins); i++) {
    pinMode(Pins[i], OUTPUT);
  }
}

// #define await                                                                  \
//   if (interrupt())                                                             \
//     return;

// bool _interrupt = false;

// bool interrupt() {
//   int nextReversed = digitalRead(SwitchPin);
//   if (nextReversed != reversed) {

//   }

//   // if (digitalRead(1) == HIGH) {
//   //   _interrupt = true;
//   //   return true;
//   // }
//   return _interrupt;
// }

bool reverse = false;

// Reverse pin index, if needed.
int xform(int i) { return reverse ? sizeof(Pins) - i - 1 : i; }

void go() {
  // // Hardcoded version:
  // await setPins(M, H, _, _, _);
  // await setPins(S, F, _, _, _);
  // await setPins(M, H, H, _, _);
  // await setPins(S, _, F, _, _);
  // await setPins(M, _, H, H, _);
  // await setPins(S, _, _, F, _);
  // await setPins(M, _, _, H, H);
  // await setPins(S, _, _, _, F);
  // await setPins(M, _, _, _, H);
  // await setPins(L, _, _, _, _);

  // Algorithmically generated version:
  for (int i = 0; i <= sizeof(Pins); i++) {
    int prev = xform(i) == 0 ? 0 : Pins[xform(i - 1)];
    int curr = xform(i) == sizeof(Pins) ? 0 : Pins[xform(i)];

    if (prev)
      analogWrite(prev, H);
    if (curr)
      analogWrite(curr, H);
    delay(M);

    if (prev)
      analogWrite(prev, _);
    if (curr)
      analogWrite(curr, F);
    delay(S);
  }

  delay(L);
}

void loop() {
  go();
  reverse = digitalRead(SwitchPin);
}
